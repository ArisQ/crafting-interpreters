// GENERATED BY ast_generator. DO NOT EDIT.
#ifndef _EXPR_H_
#define _EXPR_H_

#include <iostream>
#include "token.h"

// GENERATOR_START
// Assign      : Token name, *Expr value
// Binary      : *Expr left, Token op, *Expr right
// Grouping    : *Expr expression
// Literal     : *Value value
// Unary       : Token op, *Expr right
// Variable    : Token name
// GENERATED
// class declaration
class Assign;
class Binary;
class Grouping;
class Literal;
class Unary;
class Variable;

// templated vistor for inherit
template <typename T>
class ExprVisitor {
public:
    virtual T visitAssign(Assign *) = 0;
    virtual T visitBinary(Binary *) = 0;
    virtual T visitGrouping(Grouping *) = 0;
    virtual T visitLiteral(Literal *) = 0;
    virtual T visitUnary(Unary *) = 0;
    virtual T visitVariable(Variable *) = 0;
};

// internal general vistor for virtual accept
class _ExprVisitor {
public:
    virtual std::shared_ptr<void> visitAssign(Assign *) = 0;
    virtual std::shared_ptr<void> visitBinary(Binary *) = 0;
    virtual std::shared_ptr<void> visitGrouping(Grouping *) = 0;
    virtual std::shared_ptr<void> visitLiteral(Literal *) = 0;
    virtual std::shared_ptr<void> visitUnary(Unary *) = 0;
    virtual std::shared_ptr<void> visitVariable(Variable *) = 0;
};

// templated vistor to internal vistor
template <typename T>
class ExprVisitorConvertor: public _ExprVisitor {
    ExprVisitor<T> *v;
public:
    ExprVisitorConvertor(ExprVisitor<T> *v): v(v) {}
    std::shared_ptr<void> visitAssign(Assign *e) {
        return std::static_pointer_cast<void>(std::make_shared<T>(v->visitAssign(e)));
    }
    std::shared_ptr<void> visitBinary(Binary *e) {
        return std::static_pointer_cast<void>(std::make_shared<T>(v->visitBinary(e)));
    }
    std::shared_ptr<void> visitGrouping(Grouping *e) {
        return std::static_pointer_cast<void>(std::make_shared<T>(v->visitGrouping(e)));
    }
    std::shared_ptr<void> visitLiteral(Literal *e) {
        return std::static_pointer_cast<void>(std::make_shared<T>(v->visitLiteral(e)));
    }
    std::shared_ptr<void> visitUnary(Unary *e) {
        return std::static_pointer_cast<void>(std::make_shared<T>(v->visitUnary(e)));
    }
    std::shared_ptr<void> visitVariable(Variable *e) {
        return std::static_pointer_cast<void>(std::make_shared<T>(v->visitVariable(e)));
    }
};

// 返回值类型为shared_ptr的模板特化
template <typename T>
class ExprVisitorConvertor<std::shared_ptr<T>>: public _ExprVisitor {
    ExprVisitor<std::shared_ptr<T>> *v;
public:
    ExprVisitorConvertor(ExprVisitor<std::shared_ptr<T>> *v): v(v) {}
    std::shared_ptr<void> visitAssign(Assign *e) {
        return std::static_pointer_cast<void>(v->visitAssign(e));
    }
    std::shared_ptr<void> visitBinary(Binary *e) {
        return std::static_pointer_cast<void>(v->visitBinary(e));
    }
    std::shared_ptr<void> visitGrouping(Grouping *e) {
        return std::static_pointer_cast<void>(v->visitGrouping(e));
    }
    std::shared_ptr<void> visitLiteral(Literal *e) {
        return std::static_pointer_cast<void>(v->visitLiteral(e));
    }
    std::shared_ptr<void> visitUnary(Unary *e) {
        return std::static_pointer_cast<void>(v->visitUnary(e));
    }
    std::shared_ptr<void> visitVariable(Variable *e) {
        return std::static_pointer_cast<void>(v->visitVariable(e));
    }
};

// 返回值类型为void的模板特化
template <>
class ExprVisitorConvertor<void>: public _ExprVisitor {
    ExprVisitor<void> *v;
public:
    ExprVisitorConvertor(ExprVisitor<void> *v): v(v) {}
    std::shared_ptr<void> visitAssign(Assign *e) {
        v->visitAssign(e);
        return nullptr;
    }
    std::shared_ptr<void> visitBinary(Binary *e) {
        v->visitBinary(e);
        return nullptr;
    }
    std::shared_ptr<void> visitGrouping(Grouping *e) {
        v->visitGrouping(e);
        return nullptr;
    }
    std::shared_ptr<void> visitLiteral(Literal *e) {
        v->visitLiteral(e);
        return nullptr;
    }
    std::shared_ptr<void> visitUnary(Unary *e) {
        v->visitUnary(e);
        return nullptr;
    }
    std::shared_ptr<void> visitVariable(Variable *e) {
        v->visitVariable(e);
        return nullptr;
    }
};

// Expr definition
struct Expr {
    template <typename T>
    T accept(ExprVisitor<T> *const v) {
        auto visitor = ExprVisitorConvertor<T>(v);
        return *(std::static_pointer_cast<T>(this->_accept(&visitor)));
    }

    template <typename T>
    std::shared_ptr<T> accept(ExprVisitor<std::shared_ptr<T>> *const v) {
        auto visitor = ExprVisitorConvertor<std::shared_ptr<T>>(v);
        return std::static_pointer_cast<T>(this->_accept(&visitor));
    }

    // c++ 成员函数不支持template + virtual
    // 分成两步
    // virtual的_accept用于继承，使用通用类型的visitor
    // 基类实现template的accept，不需要子类继承，仅做类型转换后调用使用通用类型的virtual的_accept
    virtual std::shared_ptr<void> _accept(_ExprVisitor* const) = 0;
};
template <>
inline void Expr::accept<void>(ExprVisitor<void> *const v) {
    auto visitor = ExprVisitorConvertor<void>(v);
    this->_accept(&visitor);
}

struct Assign: public Expr {
    Token name;
    std::shared_ptr<Expr> value;

    std::shared_ptr<void> _accept(_ExprVisitor * const v) { return v->visitAssign(this); }
    Assign(Token name, std::shared_ptr<Expr> value): name(name), value(value) {}
};

struct Binary: public Expr {
    std::shared_ptr<Expr> left;
    Token op;
    std::shared_ptr<Expr> right;

    std::shared_ptr<void> _accept(_ExprVisitor * const v) { return v->visitBinary(this); }
    Binary(std::shared_ptr<Expr> left, Token op, std::shared_ptr<Expr> right): left(left), op(op), right(right) {}
};

struct Grouping: public Expr {
    std::shared_ptr<Expr> expression;

    std::shared_ptr<void> _accept(_ExprVisitor * const v) { return v->visitGrouping(this); }
    Grouping(std::shared_ptr<Expr> expression): expression(expression) {}
};

struct Literal: public Expr {
    std::shared_ptr<Value> value;

    std::shared_ptr<void> _accept(_ExprVisitor * const v) { return v->visitLiteral(this); }
    Literal(std::shared_ptr<Value> value): value(value) {}
};

struct Unary: public Expr {
    Token op;
    std::shared_ptr<Expr> right;

    std::shared_ptr<void> _accept(_ExprVisitor * const v) { return v->visitUnary(this); }
    Unary(Token op, std::shared_ptr<Expr> right): op(op), right(right) {}
};

struct Variable: public Expr {
    Token name;

    std::shared_ptr<void> _accept(_ExprVisitor * const v) { return v->visitVariable(this); }
    Variable(Token name): name(name) {}
};

// GENERATOR_END

#endif // _EXPR_H_
